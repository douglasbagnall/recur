#!/usr/bin/python

import os, sys
import argparse
import json
import csv
import re
import random

from classify_stats import draw_roc_curve, calc_stats, draw_presence_roc
from classify_stats import actually_show_roc

def get_top_score_json_scores_and_names(fn, index):
    f = open(fn)
    results = {}
    for line in f:
        a = json.loads(line)
        n = os.path.basename(a[0]).encode('utf-8')
        n = n.replace('.wav-8k.wav', '.wav')
        results[n] = a[index + 1]
    return results



def get_call_json_presence_scores_and_names(fn):
    f = open(fn)
    results = {}
    for line in f:
        a = json.loads(line)
        score = 0
        for s, e, sc in a[1:]:
            if sc > score:
                score = sc
        n = os.path.basename(a[0]).encode('utf-8')
        n = n.replace('.wav-8k.wav', '.wav')
        results[n] = score
    return results

def get_csv_species_presence(fn, species_re):
    results = {}
    times = {}
    species = re.compile(species_re)
    with open(fn) as f:
        for record in csv.DictReader(f):
            wav = record['filename']
            if species.search(record['name']):
                t = times.setdefault(wav, [])
                t.append(record['offset'])
                results[wav] = True
            elif wav not in results:
                results[wav] = False
    return times, results


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--csv', action='append',
                        help="CSV of doc calls (possibly multiple)")
    parser.add_argument('--call-json',
                        help="JSON of classified calls")
    parser.add_argument('--json',
                        help="JSON of call top scores")
    parser.add_argument('--score-index', type=int,
                        help="Nth highest score to indicate presence")
    parser.add_argument('--species-regex',
                        help="species to look for in DOC csv")
    parser.add_argument('--threshold', type=float,
                        help="threshold for simple calculations")

    args = parser.parse_args()
    if args.call_json:
        predictions = get_call_json_presence_scores_and_names(args.call_json)
    else:
        index = args.score_index
        predictions = get_top_score_json_scores_and_names(args.json, index)

    truth = {}
    times = {}
    for csvfn in args.csv:
        ftimes, ftruth = get_csv_species_presence(csvfn, args.species_regex)
        times.update(ftimes)
        truth.update(ftruth)

    if args.threshold:        
        tp, fp, tn, fn = [], [], [], []
        not_in_csv, not_in_pred = 0, 0
        for k in truth:            
            not_in_pred += k not in predictions
            if k not in predictions:
                print k
        for k, p in predictions.items():
            t = truth.get(k)
            predicted = p > args.threshold
            if t is None:
                not_in_csv += 1
                if predicted:
                    fp.append(k)
                else:
                    tn.append(k)
            elif not t:
                if predicted:
                    fp.append(k)
                else:
                    tn.append(k)
            else:
                if predicted:
                    tp.append(k)
                else:
                    fn.append(k)

        print "tp %d" % len(tp)
        print "fp %d" % len(fp)
        print "fn %d" % len(fn)
        print "tn %d" % len(tn)
        print "missing from truth %d" % not_in_csv
        print "missing from predictions %d" % not_in_pred
        
        print "10 random false negatives:"
        random.shuffle(fn)
        for x in range(10):
            print "   ", fn[x], times.get(fn[x], '-')
        print "10 random false positives:"
        random.shuffle(fp)
        for x in range(10):
            print "   ", fp[x]


    #print truth

    data = []
    for k, v in predictions.iteritems():
        gt = truth.get(k, False)
        data.append((v, gt))

    draw_roc_curve(data, arrows=1)
    print calc_stats(data)
    actually_show_roc()

main()
