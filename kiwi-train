#!/usr/bin/python
import os, sys
import random
import itertools
import time
import argparse

from classify_kiwi import MFCCS, WINDOW_SIZE, BASENAME
from classify_kiwi import MIN_FREQUENCY, MAX_FREQUENCY, KNEE_FREQUENCY

from classify import targeted_wav_finder, gst_init
from classify import Trainer, lr_steps, load_timings
from classify import add_common_args

def main():
    gst_init()
    parser = argparse.ArgumentParser()
    add_common_args(parser, WINDOW_SIZE=WINDOW_SIZE,
                    BASENAME=BASENAME)
    parser.add_argument('-l', '--learn-rate', type=float,
                        help="learning rate")
    parser.add_argument('-N', '--no-save-net', action='store_true',
                        help="don't save the net, periodically or otherwise")
    parser.add_argument('-C', '--channels', default=12, type=int,
                        help="how many channels to use")
    parser.add_argument('-r', '--random-alignment', action='store_true',
                        help="slightly randomise alignment of fft windows")
    parser.add_argument('-E', '--error-weights',
                        help="multiply output errors by these ratios")

    args = parser.parse_args()
    if args.learn_rate:
        lr = lr_steps(args.learn_rate)
    else:
        lr = lr_steps(
            3e-5, 20,
            1e-5, 80,
            3e-6, 100,
            1e-6, 200,
            3e-7, 400,
            1e-7, 2000,
            3e-8)
    if 0:
        dropout = lr_steps(0.5, 100,
                           0.4, 100,
                           0.3, 100,
                           0.2, 100,
                           0.1, 100,
                           0
                       )
    else:
        dropout = 0


    random.seed(1)

    n_channels = args.channels

    c = Trainer(channels=n_channels)

    c.no_save_net = args.no_save_net
    c.quiet = not args.verbose

    c.setp('random-alignment', args.random_alignment)

    if args.net_filename:
        c.setup_from_file(args.net_filename)
    else:
        c.setup(MFCCS,
                args.hidden_size,
                args.classes,
                window_size=args.window_size,
                bottom_layer=args.bottom_layer,
                basename=args.basename,
                min_freq=MIN_FREQUENCY,
                max_freq=MAX_FREQUENCY,
                knee_freq=KNEE_FREQUENCY)

    timed_files, full_timings = load_timings(c.classes,
                                             args.timings,
                                             args.audio_directory)

    validate_streams = [[ffn for fn, ffn in timed_files[:n_channels]]]
    training_streams = [[ffn for fn, ffn in timed_files[n_channels:]]]

    for x in training_streams:
        random.shuffle(x)

    if args.error_weights:
        c.setp('error-weight', args.error_weights)

    c.train(training_streams, validate_streams, full_timings,
            iterations=args.iterations,
            learn_rate=lr, dropout=dropout,
            properties=(('momentum-soft-start', 10000),
                        ('momentum', 0.95),
                        ('momentum-style', 1),
                        ('weight-fan-in-sum', 3),
                        ('weight-fan-in-kurtosis', 0.15),
                        ('weight-diagonal', 0.33),
                    ))

main()
