#!/usr/bin/python
import os, sys
import random
import itertools
import time

from classify import gst_init, TRAINING, TESTING
from classify import KIWI_MFCCS as MFCCS
from classify import KIWI_CLASSES as CLASSES
from classify import KIWI_HIDDEN_SIZE as HIDDEN_SIZE
from classify import KIWI_WINDOW_SIZE as WINDOW_SIZE
from classify import KIWI_BASENAME as BASENAME
from classify import COLOURS
from classify import Trainer, lr_steps, categorised_files

NET_LOG_FILE = "kiwi.log"

TRAIN_AUDIO_DIR = "/home/douglas/corpora/kiwi/train/"
VALIDATE_AUDIO_DIR = "/home/douglas/corpora/kiwi/validate/"

KIWI_TIMING_DATA = '/home/douglas/corpora/kiwi/times.txt'

QUIET = False

class KiwiTrainer(Trainer):
    def next_training_set(self):
        targets = []
        self.targets = []
        starttime = self.timestamp
        self.timestamp = time.time()
        if self.learn_rate is not None:
            r = self.learn_rate.next() * self.lr_adjust
            print ("%s/%s learn_rate %s elapsed %.2f" %
                   (self.counter, self.iterations, r, self.timestamp - starttime))
            self.classifier.set_property('learn_rate', r)

        for fs in self.filesrcs:
            c, fn = self.trainers.next()
            timings = self.timings[fn]
            self.targets.append(c)
            targets.extend('c%dt%.2f' % x for x in timings)
            targets.append(' ')
            fs.set_property('location', fn)
            if not self.quiet:
                print c, fn, timings

        target_string = ''.join(targets) + ' '
        self.classifier.set_property('target', target_string)
        self.mode = TRAINING

    def test_set(self):
        self.test_scores = [0] * len(self.classes)
        self.test_runs = [0] * len(self.classes)
        self.classifier.set_property('forget', 0)
        self.next_training_set()
        self.classifier.set_property('training', 0)
        self.mode = TESTING
        self.test_n = 0

    def on_element(self, bus, msg):
        total = 0
        s = msg.get_structure()
        name = s.get_name()
        if name == 'classify-setup':
            print "got message", name
        elif name == 'classify' and self.mode == TESTING:
            self.test_n += self.channels
            v = s.get_value
            for i in range(self.channels):
                #winner = v('channel %d winner' % i)
                target = v('channel %d target' % i)
                correct = v('channel %d correct' % i)
                self.test_scores[target] += correct
                self.test_runs[target] += 1
                total += correct
                #print target

    def evaluate_test(self):
        #print self.test_scores
        colours = [COLOURS[x] for x in 'PPrRYYGGgCC']
        output = []
        rightness = 0
        winners = 0
        good_enough = 10 / len(self.classes)
        results = zip(self.classes, self.test_scores, self.test_runs)
        for c, s, r in results:
            x = float(s) / r
            i = int(x * 9.99)
            output.append(colours[i])
            output.append(c)
            output.append(' %.2f%s %d/%d ' % (x, COLOURS['Z'], s, r))
            rightness += x
            winners += i > good_enough
        rightness /= len(self.classes)
        winners /= float(len(self.classes))
        output += (" %s%.2f%s %.2f%s" %
                   (colours[int(rightness * 9.99)], rightness,
                    colours[int(winners * 9.99)], winners,
                    COLOURS['Z']))
        print ''.join(output)
        if winners > 0.9:
            self.save_net(tag='goodness-%d-%d' %
                          (int(rightness * 100), int(winners * 100)))
        if rightness > 0.75:
            self.lr_adjust = 0.1 / (rightness - 0.65)
        else:
            self.lr_adjust = 1.0



def load_timings(fn, default='N'):
    f = open(fn)
    timings = {}
    default_i = CLASSES.index(default)
    for line in f:
        d = line.split()
        wavname = os.path.basename(d[0])
        klass = wavname[0]
        if klass not in CLASSES:
            continue
        events = [(default_i, 0)]
        if klass != default and len(d) > 1:
            klass_i = CLASSES.index(klass)
            for i, t in enumerate(d[1:]):
                if i & 1:
                    events.append((default_i, float(t)))
                else:
                    events.append((klass_i, float(t)))
            #don't duplicate numbers
            if events[1][1] == 0:
                del events[0]
        timings[d[0]] = events
    if not QUIET:
        for k, v in timings.items():
            if k[0] != default:
                print k, v
    return timings

def main(argv):
    global QUIET
    gst_init()
    if '-q' in argv:
        argv.remove('-q')
        QUIET = True
    if argv:
        lr = lr_steps(*(float(x) for x in argv))

    else:
        lr = lr_steps(#3e-5, 2,
                      1e-5, 6,
                      3e-6, 18,
                      1e-6, 54,
                      3e-7, 108,
                      1e-7)


    train_data = categorised_files(TRAIN_AUDIO_DIR, CLASSES)
    test_data = categorised_files(VALIDATE_AUDIO_DIR, CLASSES)

    c = KiwiTrainer(mfccs=MFCCS,
                    hsize=HIDDEN_SIZE,
                    channels=72,
                    classes=CLASSES,
                    window_size=WINDOW_SIZE,
                    basename=BASENAME)
    c.quiet = QUIET
    c.timings = load_timings(KIWI_TIMING_DATA)

    trainers = []
    testers = []
    for k in CLASSES[:-1] * 4 + CLASSES[-1]:
        trainers.append([(k, x) for x in train_data[k]])
        testers.append([(k, x) for x in test_data[k]])
    try:
        c.train(trainers, testers, iterations=1000,
                learn_rate=lr, log_file=NET_LOG_FILE,
                properties=(('log-class-numbers', 1),
                            ('momentum-soft-start', 5000),
                            ('momentum', 0.95),
                            ))
    finally:
        pass
        #c.classifier.set_property('save-net', '')


main(sys.argv[1:])
