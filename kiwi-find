#!/usr/bin/python
import os, sys
import random
import itertools
import time

from classify import gst_init, TRAINING, TESTING, Gst
from classify import KIWI_MFCCS as MFCCS
from classify import KIWI_CLASSES as CLASSES
from classify import KIWI_HIDDEN_SIZE as HIDDEN_SIZE
from classify import KIWI_WINDOW_SIZE as WINDOW_SIZE
from classify import KIWI_BASENAME as BASENAME
from classify import COLOURS
from classify import BaseClassifier, load_timings

from math import *
import numpy as np
try:
    from scipy.signal import fftconvolve as convolve
except ImportError:
    print >> sys.stderr, "Can't find scipy.signal, trying numpy"
    from numpy import convolve

TEST_AUDIO_DIR = "/home/douglas/corpora/kiwi/test/"
KIWI_TIMING_DATA = '/home/douglas/corpora/kiwi/times.txt'

QUIET = False

class KiwiClassifier(BaseClassifier):
    pending_files = []
    quiet = False

    def classify_files_emitting_timings(self, files):
        self.pending_files = files
        self.classifier.set_property('mode', -1)
        self.load_next_file()
        self.mainloop.run()

    def load_next_file(self):
        self.pipeline.set_state(Gst.State.READY)
        fn = self.pending_files.pop()
        self.current_file = fn
        self.current_winner = None
        self.classifier.set_property("forget", 0)
        self.filesrcs[0].set_property('location', fn)
        self.winners = []
        self.times = []
        self.pipeline.set_state(Gst.State.PLAYING)

    def on_element(self, bus, msg):
        s = msg.get_structure()
        if s.get_name() != "classify":
            return
        v = s.get_value
        winner = v('channel 0 winner')
        self.winners.append(winner)
        self.times.append(msg.timestamp)

    def print_file_results(self):
        #self.pipeline.set_state(Gst.State.READY)
        #XXX base step on discoverable values
        frame_size = WINDOW_SIZE / (2.0 * 8000.0)
        margin = int(2.0 / frame_size)

        times = []
        #result is 1 for noise, 0 for kiwi.
        results = np.array([1] * margin +
                           self.winners +
                           [1] * margin, dtype=np.float32)
        results -= 0.5
        # a gaussian window, roughly 0.0111 on the edge
        window = np.array([exp(-0.5 * ((x - margin) * 3.0 / margin) ** 2)
                           for x in range(margin * 2 + 1)])

        blurred = convolve(results, window, 'same')
        times = []
        prev = 1
        for t, v in zip(self.times, blurred):
            state = v > 10
            if state != prev:
                times.append(t * 1e-9)
                prev = state

        if len(times) & 1:
            times.append(self.times[-1] * 1e-9 + frame_size)

        print self.current_file,
        print " ".join("%.1f" %x for x in times)
        #self.pipeline.set_state(Gst.State.PLAYING)


    def on_eos(self, bus, msg):
        self.print_file_results()
        if self.pending_files:
            self.load_next_file()
        else:
            self.stop()

    def on_error(self, bus, msg):
        pass

def main(argv):
    global QUIET
    gst_init()
    if '-q' in argv:
        argv.remove('-q')
        QUIET = True

    c = KiwiClassifier(mfccs=MFCCS,
                       hsize=HIDDEN_SIZE,
                       channels=1,
                       classes=CLASSES,
                       window_size=WINDOW_SIZE,
                       basename=BASENAME)
    c.quiet = QUIET
    allfiles = []
    for d, dirs, files in os.walk(argv[0]):
        allfiles.extend([os.path.join(d, f) for f in files if
                         f.endswith('.wav')])
    allfiles.sort()
    allfiles.reverse()
    c.classify_files_emitting_timings(allfiles)

main(sys.argv[1:])
